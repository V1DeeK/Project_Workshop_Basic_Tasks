// Подключаем библиотеку SFML для работы с графикой
#include <SFML/Graphics.hpp>
// Подключаем библиотеку для математических функций (atan2, sqrt)
#include <cmath>

// Структура Arrow - описывает стрелку, состоящую из треугольника и прямоугольника
// struct - ключевое слово для создания пользовательского типа данных
// Структура объединяет несколько переменных в один объект
struct Arrow
{
    // head - треугольник (наконечник стрелки)
    // sf::ConvexShape - класс для рисования выпуклых многоугольников
    sf::ConvexShape head;
    
    // stem - прямоугольник (стержень стрелки)
    // sf::RectangleShape - класс для рисования прямоугольников
    sf::RectangleShape stem;
    
    // position - позиция стрелки в окне
    // sf::Vector2f - вектор из двух float значений (x, y)
    sf::Vector2f position;
    
    // rotation - угол поворота стрелки в радианах
    // float - число с плавающей точкой
    // = 0 - начальное значение (стрелка не повернута)
    float rotation = 0;
};

// Функция инициализации стрелки
// void - функция не возвращает значение
// initArrow() - имя функции
// Arrow& arrow - ссылка на структуру Arrow (изменения будут применены к оригиналу)
// & - означает передачу по ссылке (не копирование)
void initArrow(Arrow& arrow)
{
    // === ИНИЦИАЛИЗАЦИЯ ТРЕУГОЛЬНИКА (НАКОНЕЧНИК СТРЕЛКИ) ===
    // Устанавливаем количество вершин треугольника
    // setPointCount(3) - треугольник имеет 3 вершины
    arrow.head.setPointCount(3);
    
    // Устанавливаем координаты вершин треугольника
    // Треугольник направлен вправо (в сторону положительной оси X)
    // setPoint(номер_вершины, координаты) - задает координаты вершины
    // Вершины задаются в локальных координатах (относительно центра фигуры)
    arrow.head.setPoint(0, sf::Vector2f(0, -20));   // Верхняя вершина
    arrow.head.setPoint(1, sf::Vector2f(0, 20));    // Нижняя вершина
    arrow.head.setPoint(2, sf::Vector2f(40, 0));    // Правая вершина (острие)
    
    // Устанавливаем цвет заливки треугольника
    // sf::Color::Red - предопределенный красный цвет
    arrow.head.setFillColor(sf::Color::Red);
    
    // === ИНИЦИАЛИЗАЦИЯ ПРЯМОУГОЛЬНИКА (СТЕРЖЕНЬ СТРЕЛКИ) ===
    // Создаем прямоугольник для стержня стрелки
    // sf::Vector2f(100, 10) - размер: ширина 100, высота 10 пикселей
    arrow.stem.setSize(sf::Vector2f(100, 10));
    
    // Устанавливаем цвет заливки прямоугольника
    arrow.stem.setFillColor(sf::Color::Blue);
    
    // Устанавливаем точку origin для прямоугольника
    // origin - точка, относительно которой происходит поворот и позиционирование
    // По умолчанию origin = (0, 0) - левый верхний угол
    // Мы устанавливаем origin в центр прямоугольника для вращения вокруг центра
    // setOrigin({x, y}) - устанавливает точку origin
    // 50, 5 - центр прямоугольника (ширина/2, высота/2)
    arrow.stem.setOrigin({50, 5});
    
    // === ИНИЦИАЛИЗАЦИЯ ПОЗИЦИИ И ПОВОРОТА ===
    // Устанавливаем начальную позицию стрелки в центре окна
    // 400, 300 - центр окна размером 800x600
    arrow.position = {400, 300};
    
    // Устанавливаем начальный угол поворота (0 радиан = 0 градусов)
    arrow.rotation = 0;
    
    // Вызываем функцию обновления элементов стрелки
    // Это необходимо для применения начальных позиций и поворота
    // updateArrowElements() - функция, которая обновит позиции и повороты компонентов
    // Мы вызовем ее после объявления функции
}

// Функция обновления элементов стрелки
// Обновляет позиции и повороты треугольника и прямоугольника
// согласно полям position и rotation структуры Arrow
void updateArrowElements(Arrow& arrow)
{
    // === ОБНОВЛЕНИЕ ПРЯМОУГОЛЬНИКА (СТЕРЖЕНЬ) ===
    // Устанавливаем позицию прямоугольника
    // setPosition() - устанавливает позицию фигуры
    // arrow.position - позиция из структуры Arrow
    arrow.stem.setPosition(arrow.position);
    
    // Поворачиваем прямоугольник вокруг его центра
    // setRotation() - устанавливает угол поворота в градусах
    // arrow.rotation - угол в радианах из структуры Arrow
    // Преобразуем радианы в градусы: радианы * 180 / π
    // static_cast<float>(M_PI) - константа Пи (3.14159...)
    arrow.stem.setRotation(arrow.rotation * 180.0f / static_cast<float>(M_PI));
    
    // === ОБНОВЛЕНИЕ ТРЕУГОЛЬНИКА (НАКОНЕЧНИК) ===
    // Треугольник должен быть повернут так же, как прямоугольник
    // И находиться на конце стержня
    
    // Вычисляем позицию треугольника на конце стержня
    // Используем тригонометрию для вычисления координат конца стержня
    // Длина стержня: 100 пикселей (половина = 50)
    // std::cos() и std::sin() - тригонометрические функции
    // arrow.rotation - угол поворота в радианах
    const float stemLength = 50.0f;  // Половина длины стержня
    sf::Vector2f headPosition = {
        arrow.position.x + stemLength * std::cos(arrow.rotation),  // X координата
        arrow.position.y + stemLength * std::sin(arrow.rotation)   // Y координата
    };
    
    // Устанавливаем позицию треугольника
    arrow.head.setPosition(headPosition);
    
    // Поворачиваем треугольник так же, как прямоугольник
    // Преобразуем радианы в градусы
    arrow.head.setRotation(arrow.rotation * 180.0f / static_cast<float>(M_PI));
}

// Главная функция программы
int main()
{
    // === СОЗДАНИЕ ОКНА ===
    // Создаем окно для отображения графики
    // sf::RenderWindow - класс для создания и управления окном
    // sf::VideoMode({800, 600}) - размер окна: ширина 800, высота 600
    // "Arrow Following Mouse" - заголовок окна
    sf::RenderWindow window(sf::VideoMode({800, 600}), "Arrow Following Mouse");
    
    // === СОЗДАНИЕ И ИНИЦИАЛИЗАЦИЯ СТРЕЛКИ ===
    // Объявляем переменную arrow типа Arrow
    Arrow arrow;
    // Вызываем функцию инициализации стрелки
    // Передаем arrow по ссылке (&), чтобы изменения применились к оригиналу
    initArrow(arrow);
    
    // === ОСНОВНОЙ ЦИКЛ ПРОГРАММЫ (GAME LOOP) ===
    // Цикл работает, пока окно открыто
    while (window.isOpen())
    {
        // === ЭТАП 1: ОБРАБОТКА СОБЫТИЙ ===
        // Цикл обработки всех событий из очереди
        // window.pollEvent() - извлекает событие из очереди (SFML 3 API)
        while (auto event = window.pollEvent())
        {
            // Проверяем, является ли событие закрытием окна
            if (event->is<sf::Event::Closed>())
            {
                // Закрываем окно, если пользователь нажал на крестик
                window.close();
            }
            
            // Обрабатываем движение мыши
            // Проверяем, является ли событие движением мыши
            if (event->is<sf::Event::MouseMoved>())
            {
                // Получаем координаты курсора мыши
                // event->getIf<sf::Event::MouseMoved>() - получаем событие движения мыши
                // ->position() - получаем позицию мыши из события
                auto mouseEvent = event->getIf<sf::Event::MouseMoved>();
                if (mouseEvent)
                {
                    // Получаем позицию мыши в окне
                    // mouseEvent->position - координаты мыши (sf::Vector2i)
                    sf::Vector2i mousePos = mouseEvent->position;
                    
                    // Вычисляем вектор от центра стрелки к позиции мыши
                    // Это вектор направления, в котором должна смотреть стрелка
                    float dx = static_cast<float>(mousePos.x) - arrow.position.x;  // Разница по X
                    float dy = static_cast<float>(mousePos.y) - arrow.position.y;  // Разница по Y
                    
                    // Вычисляем угол поворота стрелки с помощью функции atan2
                    // std::atan2(y, x) - арктангенс, возвращает угол в радианах
                    // atan2 корректно обрабатывает все квадранты (углы от -π до π)
                    // dy, dx - порядок аргументов важен! (y, x), а не (x, y)
                    arrow.rotation = std::atan2(dy, dx);
                    
                    // Обновляем элементы стрелки с новым углом поворота
                    updateArrowElements(arrow);
                }
            }
        }
        
        // === ЭТАП 2: ОБНОВЛЕНИЕ СОСТОЯНИЯ ===
        // В этом примере обновление происходит в обработчике событий мыши
        // Здесь можно добавить другую логику обновления (физика, AI и т.д.)
        
        // === ЭТАП 3: ОТРИСОВКА ===
        // Очищаем окно белым цветом перед отрисовкой нового кадра
        // window.clear() - заполняет все окно указанным цветом
        window.clear(sf::Color::White);
        
        // Рисуем стержень стрелки (прямоугольник)
        // window.draw() - добавляет фигуру в буфер отрисовки
        window.draw(arrow.stem);
        
        // Рисуем наконечник стрелки (треугольник)
        window.draw(arrow.head);
        
        // Отображаем все нарисованное на экране
        // window.display() - выводит содержимое буфера на экран
        window.display();
    }
    
    // Возвращаем 0 - код успешного завершения программы
    return 0;
}

