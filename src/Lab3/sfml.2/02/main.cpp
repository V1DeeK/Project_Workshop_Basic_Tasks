// Подключаем библиотеку SFML для работы с графикой
#include <SFML/Graphics.hpp>
// Подключаем библиотеку для математических функций (sin, cos, sqrt и т.д.)
#include <cmath>
// Подключаем библиотеку для работы с константами (M_PI - число Пи)
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// Главная функция программы
int main()
{
    // === СОЗДАНИЕ ОКНА С ПАРАМЕТРАМИ СГЛАЖИВАНИЯ ===
    // sf::ContextSettings - настройки контекста OpenGL для окна
    // settings - переменная для хранения настроек
    sf::ContextSettings settings;
    // antialiasingLevel - уровень сглаживания краев фигур
    // 8 - высокий уровень сглаживания (больше значение = лучше качество, но больше нагрузка)
    // Antialiasing - техника сглаживания краев за счет рисования полупрозрачных пикселей
    settings.antialiasingLevel = 8;
    
    // Создаем окно с параметрами сглаживания
    // sf::RenderWindow - класс для создания и управления окном
    // sf::VideoMode({800, 600}) - размер окна: ширина 800, высота 600 пикселей
    // "Moving Circle" - заголовок окна
    // sf::Style::Default - стандартный стиль окна (можно изменять размер, есть рамка)
    // settings - параметры контекста OpenGL (сглаживание)
    sf::RenderWindow window(
        sf::VideoMode({800, 600}), "Moving Circle",
        sf::Style::Default, settings);
    
    // === СОЗДАНИЕ КРУГА ЧЕРЕЗ ConvexShape ===
    // sf::ConvexShape - класс для рисования выпуклых многоугольников
    // В отличие от sf::CircleShape, ConvexShape позволяет создавать любые выпуклые фигуры
    // Мы используем его для демонстрации работы с полярными координатами
    sf::ConvexShape circle;
    
    // Количество точек для аппроксимации круга
    // Чем больше точек, тем более гладким будет круг
    // 100 точек - хороший баланс между качеством и производительностью
    const int pointCount = 100;
    
    // Устанавливаем количество вершин многоугольника
    // setPointCount() - задает количество точек, которые будут использоваться для фигуры
    circle.setPointCount(pointCount);
    
    // Радиус круга в пикселях
    // const float - константа типа float (число с плавающей точкой)
    // const означает, что значение нельзя изменить после инициализации
    const float radius = 100.0f;
    
    // Цикл для создания точек круга
    // Используем полярные координаты для равномерного распределения точек по окружности
    for (int i = 0; i < pointCount; ++i)
    {
        // Вычисляем угол для текущей точки
        // 2 * M_PI - полный оборот в радианах (360 градусов)
        // i / pointCount - доля оборота для текущей точки (от 0 до 1)
        // 2 * M_PI * i / pointCount - угол в радианах для точки i
        // M_PI - константа числа Пи (3.14159...)
        float angle = 2.0f * static_cast<float>(M_PI) * i / static_cast<float>(pointCount);
        
        // Переводим полярные координаты в декартовы (прямоугольные)
        // Полярные координаты: (угол, радиус)
        // Декартовы координаты: (x, y)
        // Формула перевода:
        // x = radius * cos(angle) - горизонтальная координата
        // y = radius * sin(angle) - вертикальная координата
        // std::cos() и std::sin() - тригонометрические функции из библиотеки <cmath>
        sf::Vector2f point = {
            radius * std::cos(angle),  // X координата точки
            radius * std::sin(angle)   // Y координата точки
        };
        
        // Устанавливаем координаты точки с номером i
        // setPoint() - задает координаты вершины многоугольника
        // i - номер точки (от 0 до pointCount-1)
        // point - координаты точки в виде sf::Vector2f (вектор из двух float)
        circle.setPoint(i, point);
    }
    
    // Устанавливаем цвет заливки круга
    // sf::Color::Blue - предопределенный синий цвет
    circle.setFillColor(sf::Color::Blue);
    
    // Устанавливаем начальную позицию круга
    // setPosition({x, y}) - устанавливает координаты центра фигуры
    // 400, 300 - центр окна (800/2, 600/2)
    circle.setPosition({400.0f, 300.0f});
    
    // Переменная для хранения времени
    // Используется для создания плавной анимации
    float time = 0.0f;
    
    // === ОСНОВНОЙ ЦИКЛ ПРОГРАММЫ (GAME LOOP) ===
    // Цикл работает, пока окно открыто
    while (window.isOpen())
    {
        // === ЭТАП 1: ОБРАБОТКА СОБЫТИЙ ===
        // Цикл обработки всех событий из очереди
        // window.pollEvent() - извлекает событие из очереди (SFML 3 API)
        while (auto event = window.pollEvent())
        {
            // Проверяем, является ли событие закрытием окна
            if (event->is<sf::Event::Closed>())
            {
                // Закрываем окно, если пользователь нажал на крестик
                window.close();
            }
        }
        
        // === ЭТАП 2: ОБНОВЛЕНИЕ СОСТОЯНИЯ ===
        // Увеличиваем время для создания анимации
        // 0.01f - скорость изменения времени (можно регулировать скорость анимации)
        // Чем больше значение, тем быстрее анимация
        time += 0.01f;
        
        // Вычисляем новую позицию круга по окружности
        // Используем тригонометрические функции для движения по кругу
        // 200.0f - радиус движения (расстояние от центра окна)
        // time - угол, который увеличивается со временем
        // std::cos(time) и std::sin(time) - координаты точки на окружности
        // 400.0f, 300.0f - центр окна (точка, вокруг которой движется круг)
        float x = 400.0f + 200.0f * std::cos(time);
        float y = 300.0f + 200.0f * std::sin(time);
        
        // Устанавливаем новую позицию круга
        // setPosition() - обновляет координаты фигуры
        circle.setPosition({x, y});
        
        // === ЭТАП 3: ОТРИСОВКА ===
        // Очищаем окно белым цветом перед отрисовкой нового кадра
        // window.clear() - заполняет все окно указанным цветом
        window.clear(sf::Color::White);
        
        // Рисуем круг на окне
        // window.draw() - добавляет фигуру в буфер отрисовки
        window.draw(circle);
        
        // Отображаем все нарисованное на экране
        // window.display() - выводит содержимое буфера на экран
        window.display();
    }
    
    // Возвращаем 0 - код успешного завершения программы
    return 0;
}
