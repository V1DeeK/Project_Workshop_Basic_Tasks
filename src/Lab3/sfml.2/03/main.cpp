// Подключаем библиотеку SFML для работы с графикой
#include <SFML/Graphics.hpp>
// Подключаем библиотеку для математических функций
#include <cmath>
// Определяем константу Пи, если она не определена
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// Главная функция программы
int main()
{
    // === СОЗДАНИЕ ОКНА С ПАРАМЕТРАМИ СГЛАЖИВАНИЯ ===
    // sf::ContextSettings - настройки контекста OpenGL
    sf::ContextSettings settings;
    // Устанавливаем уровень сглаживания краев
    // 8 - высокий уровень сглаживания для плавных краев эллипса
    settings.antialiasingLevel = 8;
    
    // Создаем окно с параметрами сглаживания
    // sf::RenderWindow - класс для создания и управления окном
    // sf::VideoMode({800, 600}) - размер окна: ширина 800, высота 600
    // "Ellipse" - заголовок окна
    // sf::Style::Default - стандартный стиль окна
    // settings - параметры контекста (сглаживание)
    sf::RenderWindow window(
        sf::VideoMode({800, 600}), "Ellipse",
        sf::Style::Default, settings);
    
    // === СОЗДАНИЕ ЭЛЛИПСА ЧЕРЕЗ ConvexShape ===
    // sf::ConvexShape - класс для рисования выпуклых многоугольников
    // SFML не имеет встроенного класса для эллипсов, поэтому используем ConvexShape
    sf::ConvexShape ellipse;
    
    // Количество точек для аппроксимации эллипса
    // 200 точек - высокое качество, гладкий эллипс
    // Чем больше точек, тем более гладким будет эллипс
    const int pointCount = 200;
    
    // Устанавливаем количество вершин многоугольника
    // setPointCount() - задает количество точек для фигуры
    ellipse.setPointCount(pointCount);
    
    // Радиусы эллипса по осям X и Y
    // sf::Vector2f - вектор из двух float значений
    // {200.0f, 80.0f} - радиус по горизонтали 200, по вертикали 80
    // Эллипс будет шире, чем выше (растянут по горизонтали)
    const sf::Vector2f ellipseRadius = {200.0f, 80.0f};
    
    // Цикл для создания точек эллипса
    // Используем полярные координаты для равномерного распределения точек
    for (int i = 0; i < pointCount; ++i)
    {
        // Вычисляем угол для текущей точки
        // 2 * M_PI - полный оборот в радианах (360 градусов)
        // i / pointCount - доля оборота для текущей точки (от 0 до 1)
        // 2 * M_PI * i / pointCount - угол в радианах для точки i
        float angle = 2.0f * static_cast<float>(M_PI) * i / static_cast<float>(pointCount);
        
        // Переводим полярные координаты в декартовы для эллипса
        // Для эллипса используем разные радиусы по осям X и Y
        // x = ellipseRadius.x * cos(angle) - горизонтальная координата
        // y = ellipseRadius.y * sin(angle) - вертикальная координата
        // std::cos() и std::sin() - тригонометрические функции
        sf::Vector2f point = {
            ellipseRadius.x * std::cos(angle),  // X координата (горизонтальная)
            ellipseRadius.y * std::sin(angle)    // Y координата (вертикальная)
        };
        
        // Устанавливаем координаты точки с номером i
        // setPoint() - задает координаты вершины многоугольника
        // i - номер точки (от 0 до pointCount-1)
        // point - координаты точки в виде sf::Vector2f
        ellipse.setPoint(i, point);
    }
    
    // Устанавливаем цвет заливки эллипса
    // sf::Color::Green - предопределенный зеленый цвет
    ellipse.setFillColor(sf::Color::Green);
    
    // Устанавливаем позицию эллипса в центре окна
    // setPosition({x, y}) - устанавливает координаты центра фигуры
    // 400, 300 - центр окна (800/2, 600/2)
    ellipse.setPosition({400.0f, 300.0f});
    
    // === ОСНОВНОЙ ЦИКЛ ПРОГРАММЫ (GAME LOOP) ===
    // Цикл работает, пока окно открыто
    while (window.isOpen())
    {
        // === ЭТАП 1: ОБРАБОТКА СОБЫТИЙ ===
        // Цикл обработки всех событий из очереди
        // window.pollEvent() - извлекает событие из очереди (SFML 3 API)
        while (auto event = window.pollEvent())
        {
            // Проверяем, является ли событие закрытием окна
            if (event->is<sf::Event::Closed>())
            {
                // Закрываем окно, если пользователь нажал на крестик
                window.close();
            }
        }
        
        // === ЭТАП 2: ОБНОВЛЕНИЕ СОСТОЯНИЯ ===
        // В этом примере эллипс статичен, обновление не требуется
        // В реальных приложениях здесь обновляются позиции объектов, физика и т.д.
        
        // === ЭТАП 3: ОТРИСОВКА ===
        // Очищаем окно белым цветом перед отрисовкой нового кадра
        // window.clear() - заполняет все окно указанным цветом
        window.clear(sf::Color::White);
        
        // Рисуем эллипс на окне
        // window.draw() - добавляет фигуру в буфер отрисовки
        window.draw(ellipse);
        
        // Отображаем все нарисованное на экране
        // window.display() - выводит содержимое буфера на экран
        window.display();
    }
    
    // Возвращаем 0 - код успешного завершения программы
    return 0;
}

