// Подключаем библиотеку SFML для работы с графикой
#include <SFML/Graphics.hpp>
// Подключаем библиотеку для математических функций (sin, cos и т.д.)
#include <cmath>

// Определяем константу Пи, если она не определена
// M_PI - математическая константа, равная отношению длины окружности к диаметру
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// Главная функция программы
int main()
{
    // === СОЗДАНИЕ ОКНА ===
    // sf::RenderWindow - класс для создания и управления окном
    // sf::VideoMode({800, 600}) - размер окна: ширина 800, высота 600 пикселей
    // "Wave Motion with Bounce" - заголовок окна
    sf::RenderWindow window(sf::VideoMode({800, 600}), "Wave Motion with Bounce");

    // === СОЗДАНИЕ ШАРИКА ===
    // sf::CircleShape - класс для рисования круга
    // 20.0f - радиус круга в пикселях
    sf::CircleShape ball(20.0f);
    // Устанавливаем цвет заливки шарика - красный
    // sf::Color::Red - предопределенный красный цвет
    ball.setFillColor(sf::Color::Red);

    // === ПАРАМЕТРЫ ДВИЖЕНИЯ ===
    // Начальная позиция шарика по оси X
    // 0.0f - начинаем с левого края окна
    float x = 0.0f;
    // Скорость движения шарика по оси X (пикселей за кадр)
    // Положительное значение означает движение вправо
    float velocityX = 2.0f;
    // Амплитуда волнового движения (максимальное отклонение по Y от центра)
    // 100.0f - шарик будет отклоняться на 100 пикселей вверх и вниз от центра
    const float amplitude = 100.0f;
    // Частота волнового движения (количество волн на экране)
    // 0.02f - низкая частота, создает плавную волну
    const float frequency = 0.02f;
    // Центр окна по вертикали (для волнового движения)
    // 300.0f - половина высоты окна (600 / 2)
    const float centerY = 300.0f;
    // Ширина окна (для проверки столкновений со стенками)
    const float windowWidth = 800.0f;
    // Радиус шарика (для корректного отталкивания от стенок)
    const float ballRadius = 20.0f;

    // === ОСНОВНОЙ ЦИКЛ ПРОГРАММЫ (GAME LOOP) ===
    // Цикл работает, пока окно открыто
    while (window.isOpen())
    {
        // === ЭТАП 1: ОБРАБОТКА СОБЫТИЙ ===
        // Цикл обработки всех событий из очереди
        // window.pollEvent() - извлекает событие из очереди (SFML 3 API)
        // Возвращает std::optional<sf::Event> - либо событие, либо пустое значение
        while (auto event = window.pollEvent())
        {
            // Проверяем, является ли событие закрытием окна
            // event->is<sf::Event::Closed>() - проверяет тип события (SFML 3 API)
            if (event->is<sf::Event::Closed>())
            {
                // Закрываем окно, если пользователь нажал на крестик
                window.close();
            }
        }

        // === ЭТАП 2: ОБНОВЛЕНИЕ СОСТОЯНИЯ ===
        // Обновляем позицию шарика по оси X
        // Добавляем скорость к текущей позиции
        x += velocityX;

        // === ОТТАЛКИВАНИЕ ОТ ВЕРТИКАЛЬНЫХ СТЕНОК (ЛЕВОЙ И ПРАВОЙ) ===
        // Проверяем столкновение с правой стенкой окна
        // x + ballRadius - это правая граница шарика (центр + радиус)
        // windowWidth - ширина окна (правая граница окна)
        // Если правая граница шарика достигла или превысила правую границу окна
        if (x + ballRadius >= windowWidth)
        {
            // Отталкиваемся от правой стенки
            // Устанавливаем позицию точно на границе (чтобы шарик не выходил за пределы)
            // windowWidth - ballRadius - позиция, при которой правая граница шарика касается правой стенки
            x = windowWidth - ballRadius;
            // Меняем направление движения на противоположное (отталкивание)
            // velocityX = -velocityX - инвертируем скорость (если была положительной -> станет отрицательной)
            // Отрицательная скорость означает движение влево (в противоположном направлении)
            velocityX = -velocityX;
        }
        // Проверяем столкновение с левой стенкой окна
        // x - ballRadius - это левая граница шарика (центр - радиус)
        // Если левая граница шарика достигла или превысила левую границу окна (x = 0)
        else if (x - ballRadius <= 0.0f)
        {
            // Отталкиваемся от левой стенки
            // Устанавливаем позицию точно на границе
            // ballRadius - позиция, при которой левая граница шарика касается левой стенки
            x = ballRadius;
            // Меняем направление движения на противоположное (отталкивание)
            // velocityX = -velocityX - инвертируем скорость (если была отрицательной -> станет положительной)
            // Положительная скорость означает движение вправо (в противоположном направлении)
            velocityX = -velocityX;
        }

        // Вычисляем позицию шарика по оси Y с использованием волнового движения
        // Волновое движение - это движение по синусоиде
        // Формула: y = centerY + amplitude * sin(frequency * x)
        // std::sin() - функция синуса из библиотеки <cmath>
        // frequency * x - аргумент синуса (определяет частоту волны)
        // amplitude * sin(...) - амплитуда волны (максимальное отклонение)
        // centerY + ... - центр волны (вертикальный центр окна)
        float y = centerY + amplitude * std::sin(frequency * x);

        // Устанавливаем новую позицию шарика
        // setPosition({x, y}) - устанавливает координаты центра фигуры
        // x - горизонтальная координата (с учетом отталкивания от стенок)
        // y - вертикальная координата (волновое движение по синусоиде)
        ball.setPosition({x - ballRadius, y - ballRadius});
        // Вычитаем ballRadius, потому что setPosition устанавливает позицию левого верхнего угла
        // ограничивающего прямоугольника, а нам нужен центр шарика в точке (x, y)

        // === ЭТАП 3: ОТРИСОВКА ===
        // Очищаем окно белым цветом перед отрисовкой нового кадра
        // window.clear() - заполняет все окно указанным цветом
        // sf::Color::White - предопределенный белый цвет
        window.clear(sf::Color::White);

        // Рисуем шарик на окне
        // window.draw() - добавляет фигуру в буфер отрисовки
        window.draw(ball);

        // Отображаем все нарисованное на экране
        // window.display() - выводит содержимое буфера на экран
        // Без этого вызова изменения не будут видны
        window.display();
    }

    // Возвращаем 0 - код успешного завершения программы
    return 0;
}

