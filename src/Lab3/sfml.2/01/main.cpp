// Подключаем библиотеку SFML для работы с графикой
// Graphics.hpp содержит классы для рисования фигур, работы с окнами и т.д.
#include <SFML/Graphics.hpp>

// Главная функция программы - точка входа
int main()
{
    // === СОЗДАНИЕ ОКНА ===
    // Создаем окно для отображения графики
    // sf::RenderWindow - класс для создания и управления окном
    // sf::VideoMode({800, 600}) - задает размер окна: ширина 800, высота 600 пикселей
    // "Game Loop" - заголовок окна (текст в заголовке окна)
    sf::RenderWindow window(sf::VideoMode({800, 600}), "Game Loop");
    
    // === СОЗДАНИЕ ФИГУРЫ ДЛЯ ДЕМОНСТРАЦИИ ===
    // Создаем круг для визуализации движения
    // sf::CircleShape(50) - создает круг с радиусом 50 пикселей
    sf::CircleShape circle(50);
    // Устанавливаем цвет заливки круга
    // sf::Color::Blue - предопределенный синий цвет
    circle.setFillColor(sf::Color::Blue);
    // Устанавливаем начальную позицию круга
    // setPosition({x, y}) - устанавливает координаты левого верхнего угла фигуры
    // В SFML координаты: (0,0) - левый верхний угол, X растет вправо, Y растет вниз
    circle.setPosition({375, 275}); // Центр окна (800/2 - 50, 600/2 - 50)
    
    // === ОСНОВНОЙ ЦИКЛ ПРОГРАММЫ (GAME LOOP) ===
    // Паттерн Game Loop состоит из трех основных этапов:
    // 1. Обработка событий (event handling)
    // 2. Обновление состояния (update)
    // 3. Отрисовка (render)
    
    // Цикл работает, пока окно открыто
    // window.isOpen() - возвращает true, если окно открыто, false - если закрыто
    while (window.isOpen())
    {
        // === ЭТАП 1: ОБРАБОТКА СОБЫТИЙ ===
        // Обрабатываем все события, произошедшие с окном
        // События: закрытие окна, нажатие клавиш, движение мыши и т.д.
        
        // Цикл обработки всех событий из очереди
        // window.pollEvent() - извлекает событие из очереди событий (SFML 3 API)
        // Возвращает std::optional<sf::Event> - либо событие, либо пустое значение
        // auto event - автоматическое определение типа переменной
        while (auto event = window.pollEvent())
        {
            // Проверяем тип события
            // event->is<sf::Event::Closed>() - проверяет, является ли событие закрытием окна
            // Оператор -> используется для доступа к методам через указатель
            if (event->is<sf::Event::Closed>())
            {
                // Если пользователь нажал на крестик, закрываем окно
                // window.close() - закрывает окно (устанавливает флаг закрытия)
                window.close();
            }
        }
        
        // === ЭТАП 2: ОБНОВЛЕНИЕ СОСТОЯНИЯ ===
        // В этом примере мы просто двигаем круг по кругу
        // В реальной игре здесь обновляются позиции объектов, физика, AI и т.д.
        
        // Получаем текущую позицию круга
        // getPosition() - возвращает текущие координаты фигуры
        sf::Vector2f pos = circle.getPosition();
        
        // Простое движение: двигаем круг вправо
        // pos.x - координата X (горизонтальная)
        // += 0.1f - увеличиваем X на 0.1 пикселя за кадр
        // f в конце числа означает float (число с плавающей точкой)
        pos.x += 0.1f;
        
        // Если круг вышел за правую границу окна, возвращаем его в начало
        // 800 - ширина окна, 100 - диаметр круга (радиус 50 * 2)
        if (pos.x > 800 - 100)
        {
            // Возвращаем круг в начальную позицию
            pos.x = 0;
        }
        
        // Устанавливаем новую позицию круга
        // setPosition() - обновляет координаты фигуры
        circle.setPosition(pos);
        
        // === ЭТАП 3: ОТРИСОВКА ===
        // Очищаем окно перед отрисовкой нового кадра
        // window.clear() - заполняет все окно указанным цветом
        // sf::Color::White - белый цвет (предопределенная константа)
        // Это нужно, чтобы удалить предыдущий кадр
        window.clear(sf::Color::White);
        
        // Рисуем круг на окне
        // window.draw() - добавляет фигуру в буфер отрисовки
        // Фигура не отображается сразу, а добавляется в список для отрисовки
        window.draw(circle);
        
        // Отображаем все нарисованное на экране
        // window.display() - выводит содержимое буфера на экран
        // Это двойная буферизация: сначала рисуем в буфер, потом показываем
        // Это предотвращает мерцание экрана
        window.display();
    }
    
    // Возвращаем 0 - код успешного завершения программы
    return 0;
}

