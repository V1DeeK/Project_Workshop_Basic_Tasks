// Подключаем библиотеку SFML для работы с графикой
#include <SFML/Graphics.hpp>
// Подключаем библиотеку для работы со временем
#include <SFML/System.hpp>
// Подключаем библиотеку для работы с векторами
#include <vector>
// Подключаем библиотеку для математических функций
#include <cmath>

// Главная функция программы
int main()
{
    // === СОЗДАНИЕ ОКНА ===
    // Создаем окно для отображения графики
    // sf::RenderWindow - класс для создания и управления окном
    // sf::VideoMode({800, 600}) - размер окна: ширина 800, высота 600
    // "Pulsing Blocks" - заголовок окна
    sf::RenderWindow window(sf::VideoMode({800, 600}), "Pulsing Blocks");
    
    // === СОЗДАНИЕ МАССИВА ПРЯМОУГОЛЬНИКОВ ===
    // std::vector - динамический массив
    // sf::RectangleShape - класс для рисования прямоугольников
    std::vector<sf::RectangleShape> blocks;
    
    // Количество блоков для создания
    const int blockCount = 10;
    
    // Цикл для создания блоков
    for (int i = 0; i < blockCount; ++i)
    {
        // Создаем новый прямоугольник
        // Начальный размер: 30x30 пикселей
        sf::RectangleShape block(sf::Vector2f(30, 30));
        
        // Устанавливаем цвет блока
        // Используем разные цвета для разных блоков
        switch (i % 5)
        {
            case 0: block.setFillColor(sf::Color::Red); break;
            case 1: block.setFillColor(sf::Color::Green); break;
            case 2: block.setFillColor(sf::Color::Blue); break;
            case 3: block.setFillColor(sf::Color::Yellow); break;
            case 4: block.setFillColor(sf::Color::Magenta); break;
        }
        
        // Устанавливаем точку origin для блока
        // origin - точка, относительно которой происходит масштабирование
        // 15, 15 - центр блока (ширина/2, высота/2)
        block.setOrigin({15, 15});
        
        // Вычисляем начальную позицию блока
        // Блоки размещаются в сетке
        // i % 5 - столбец (0-4)
        // i / 5 - строка (0-1 для 10 блоков)
        float x = 150.0f + (i % 5) * 120.0f;  // Горизонтальное расстояние между блоками
        float y = 150.0f + (i / 5) * 300.0f;  // Вертикальное расстояние между блоками
        
        // Устанавливаем начальную позицию блока
        block.setPosition({x, y});
        
        // Добавляем блок в массив
        blocks.push_back(block);
    }
    
    // === ПЕРЕМЕННЫЕ ДЛЯ АНИМАЦИИ ===
    // Время для анимации
    float time = 0.0f;
    
    // === ОСНОВНОЙ ЦИКЛ ПРОГРАММЫ (GAME LOOP) ===
    // Создаем часы для измерения времени между кадрами
    sf::Clock clock;
    
    // Цикл работает, пока окно открыто
    while (window.isOpen())
    {
        // === ИЗМЕРЕНИЕ ВРЕМЕНИ ===
        // Получаем время, прошедшее с последнего кадра
        float deltaTime = clock.restart().asSeconds();
        
        // === ЭТАП 1: ОБРАБОТКА СОБЫТИЙ ===
        // Цикл обработки всех событий из очереди
        while (auto event = window.pollEvent())
        {
            // Проверяем, является ли событие закрытием окна
            if (event->is<sf::Event::Closed>())
            {
                // Закрываем окно, если пользователь нажал на крестик
                window.close();
            }
        }
        
        // === ЭТАП 2: ОБНОВЛЕНИЕ СОСТОЯНИЯ (АНИМАЦИЯ) ===
        // Увеличиваем время для создания анимации
        time += deltaTime;
        
        // Обновляем размеры всех блоков (пульсация)
        for (size_t i = 0; i < blocks.size(); ++i)
        {
            // Вычисляем масштаб блока с помощью синусоиды
            // Формула: масштаб = базовый_размер + амплитуда * sin(скорость * время + фаза)
            // std::sin() - функция синуса
            // i * 0.3f - фаза для каждого блока (создает волну пульсации)
            // 0.5f - амплитуда (блок изменяет размер от 0.5 до 1.5 от исходного)
            // 2.0f - скорость анимации
            float scale = 1.0f + 0.5f * std::sin(2.0f * time + i * 0.3f);
            
            // Устанавливаем новый размер блока
            // setSize() - устанавливает размер прямоугольника
            // 30 * scale - новый размер (исходный размер умноженный на масштаб)
            blocks[i].setSize(sf::Vector2f(30 * scale, 30 * scale));
            
            // Обновляем origin для правильного масштабирования
            // origin должна оставаться в центре блока
            blocks[i].setOrigin({15 * scale, 15 * scale});
        }
        
        // === ЭТАП 3: ОТРИСОВКА ===
        // Очищаем окно белым цветом перед отрисовкой нового кадра
        window.clear(sf::Color::White);
        
        // Рисуем все блоки
        for (const auto& block : blocks)
        {
            window.draw(block);
        }
        
        // Отображаем все нарисованное на экране
        window.display();
    }
    
    // Возвращаем 0 - код успешного завершения программы
    return 0;
}

