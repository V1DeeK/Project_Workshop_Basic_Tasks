// Подключаем библиотеку SFML для работы с графикой
#include <SFML/Graphics.hpp>
// Подключаем библиотеку для работы со временем
#include <SFML/System.hpp>
// Подключаем библиотеку для работы с векторами (std::vector)
#include <vector>

// Главная функция программы
int main()
{
    // === СОЗДАНИЕ ОКНА ===
    // Создаем окно для отображения графики
    // sf::RenderWindow - класс для создания и управления окном
    // sf::VideoMode({800, 600}) - размер окна: ширина 800, высота 600
    // "Moving Blocks" - заголовок окна
    sf::RenderWindow window(sf::VideoMode({800, 600}), "Moving Blocks");
    
    // === СОЗДАНИЕ МАССИВА ПРЯМОУГОЛЬНИКОВ ===
    // std::vector - динамический массив (может изменять размер)
    // sf::RectangleShape - класс для рисования прямоугольников
    // blocks - массив прямоугольников
    std::vector<sf::RectangleShape> blocks;
    
    // Количество блоков для создания
    const int blockCount = 5;
    
    // Цикл для создания блоков
    for (int i = 0; i < blockCount; ++i)
    {
        // Создаем новый прямоугольник
        // sf::RectangleShape - класс для рисования прямоугольников
        // sf::Vector2f(50, 50) - размер: ширина 50, высота 50 пикселей
        sf::RectangleShape block(sf::Vector2f(50, 50));
        
        // Устанавливаем цвет блока
        // Используем разные цвета для разных блоков
        // i % 5 - остаток от деления на 5 (значения 0-4)
        // Это позволяет использовать 5 разных цветов циклически
        switch (i % 5)
        {
            case 0: block.setFillColor(sf::Color::Red); break;      // Красный
            case 1: block.setFillColor(sf::Color::Green); break;    // Зеленый
            case 2: block.setFillColor(sf::Color::Blue); break;      // Синий
            case 3: block.setFillColor(sf::Color::Yellow); break;   // Желтый
            case 4: block.setFillColor(sf::Color::Magenta); break;  // Пурпурный
        }
        
        // Устанавливаем начальную позицию блока
        // setPosition({x, y}) - устанавливает координаты фигуры
        // i * 150 - горизонтальное расстояние между блоками
        // 300 - вертикальная позиция (центр окна по вертикали)
        block.setPosition({static_cast<float>(i * 150), 300.0f});
        
        // Добавляем блок в массив
        // push_back() - добавляет элемент в конец вектора
        blocks.push_back(block);
    }
    
    // === ПЕРЕМЕННЫЕ ДЛЯ АНИМАЦИИ ===
    // Время для анимации
    // float - число с плавающей точкой
    // 0 - начальное время
    float time = 0.0f;
    
    // === ОСНОВНОЙ ЦИКЛ ПРОГРАММЫ (GAME LOOP) ===
    // Создаем часы для измерения времени между кадрами
    // sf::Clock - класс для измерения времени
    sf::Clock clock;
    
    // Цикл работает, пока окно открыто
    while (window.isOpen())
    {
        // === ИЗМЕРЕНИЕ ВРЕМЕНИ ===
        // Получаем время, прошедшее с последнего кадра
        // clock.restart() - перезапускает часы и возвращает прошедшее время
        // asSeconds() - преобразует время в секунды (float)
        // deltaTime - время между кадрами в секундах
        float deltaTime = clock.restart().asSeconds();
        
        // === ЭТАП 1: ОБРАБОТКА СОБЫТИЙ ===
        // Цикл обработки всех событий из очереди
        // window.pollEvent() - извлекает событие из очереди (SFML 3 API)
        while (auto event = window.pollEvent())
        {
            // Проверяем, является ли событие закрытием окна
            if (event->is<sf::Event::Closed>())
            {
                // Закрываем окно, если пользователь нажал на крестик
                window.close();
            }
        }
        
        // === ЭТАП 2: ОБНОВЛЕНИЕ СОСТОЯНИЯ (АНИМАЦИЯ) ===
        // Увеличиваем время для создания анимации
        // deltaTime - время, прошедшее с последнего кадра
        // time накапливает общее время с начала программы
        time += deltaTime;
        
        // Обновляем позиции всех блоков
        // Цикл по всем блокам в массиве
        // size() - возвращает количество элементов в векторе
        for (size_t i = 0; i < blocks.size(); ++i)
        {
            // Вычисляем новую Y координату блока с помощью синусоиды
            // Формула: y = начальная_y + амплитуда * sin(скорость * время + фаза)
            // std::sin() - функция синуса из библиотеки <cmath>
            // i * 0.5f - фаза для каждого блока (создает волну)
            // 100.0f - амплитуда движения (блок движется вверх-вниз на 100 пикселей)
            // 2.0f - скорость анимации
            float offsetY = 100.0f * std::sin(2.0f * time + i * 0.5f);
            
            // Получаем текущую позицию блока
            // getPosition() - возвращает текущие координаты фигуры
            sf::Vector2f pos = blocks[i].getPosition();
            
            // Обновляем Y координату
            // 300.0f - начальная Y позиция (центр окна по вертикали)
            // offsetY - смещение, вычисленное с помощью синусоиды
            pos.y = 300.0f + offsetY;
            
            // Устанавливаем новую позицию блока
            // setPosition() - обновляет координаты фигуры
            blocks[i].setPosition(pos);
        }
        
        // === ЭТАП 3: ОТРИСОВКА ===
        // Очищаем окно белым цветом перед отрисовкой нового кадра
        // window.clear() - заполняет все окно указанным цветом
        window.clear(sf::Color::White);
        
        // Рисуем все блоки
        // Цикл по всем блокам в массиве
        for (const auto& block : blocks)
        {
            // Рисуем блок на окне
            // window.draw() - добавляет фигуру в буфер отрисовки
            // const auto& - автоматическое определение типа (ссылка на const RectangleShape)
            window.draw(block);
        }
        
        // Отображаем все нарисованное на экране
        // window.display() - выводит содержимое буфера на экран
        window.display();
    }
    
    // Возвращаем 0 - код успешного завершения программы
    return 0;
}

