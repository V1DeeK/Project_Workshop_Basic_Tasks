// Подключаем библиотеку SFML для работы с графикой
#include <SFML/Graphics.hpp>
// Подключаем библиотеку для работы со временем
#include <SFML/System.hpp>
// Подключаем библиотеку для математических функций
#include <cmath>

// Главная функция программы
int main()
{
    // === СОЗДАНИЕ ОКНА ===
    // Создаем окно для отображения графики
    // sf::RenderWindow - класс для создания и управления окном
    // sf::VideoMode({800, 600}) - размер окна: ширина 800, высота 600
    // "Pulsing Circle" - заголовок окна
    sf::RenderWindow window(sf::VideoMode({800, 600}), "Pulsing Circle");
    
    // === СОЗДАНИЕ КРУГА ===
    // Создаем круг
    // sf::CircleShape(50) - создает круг с радиусом 50 пикселей
    sf::CircleShape circle(50);
    // Устанавливаем цвет заливки круга - зеленый
    circle.setFillColor(sf::Color::Green);
    
    // Устанавливаем начальную позицию круга в центре окна
    // setPosition({x, y}) - устанавливает координаты фигуры
    // В SFML позиция круга задается для его левого верхнего угла описанного прямоугольника
    // 400 - 50 = 350 (центр окна по X минус радиус)
    // 300 - 50 = 250 (центр окна по Y минус радиус)
    circle.setPosition({350, 250});
    
    // === ПЕРЕМЕННЫЕ ДЛЯ АНИМАЦИИ ===
    // Базовый радиус круга (минимальный размер)
    // const float - константа, значение нельзя изменить
    const float baseRadius = 30.0f;
    
    // Амплитуда пульсации (насколько радиус изменяется)
    // 20 - радиус будет изменяться от 30 до 50 (baseRadius ± amplitude)
    const float amplitude = 20.0f;
    
    // Время для анимации пульсации
    // float - число с плавающей точкой
    // 0 - начальное время
    float time = 0.0f;
    
    // Скорость пульсации (как быстро круг пульсирует)
    // 2.0 - круг будет пульсировать 2 раза в секунду
    const float pulseSpeed = 2.0f;
    
    // === ОСНОВНОЙ ЦИКЛ ПРОГРАММЫ (GAME LOOP) ===
    // Создаем часы для измерения времени между кадрами
    // sf::Clock - класс для измерения времени
    sf::Clock clock;
    
    // Цикл работает, пока окно открыто
    while (window.isOpen())
    {
        // === ИЗМЕРЕНИЕ ВРЕМЕНИ ===
        // Получаем время, прошедшее с последнего кадра
        // clock.restart() - перезапускает часы и возвращает прошедшее время
        // asSeconds() - преобразует время в секунды (float)
        // deltaTime - время между кадрами в секундах
        float deltaTime = clock.restart().asSeconds();
        
        // === ЭТАП 1: ОБРАБОТКА СОБЫТИЙ ===
        // Цикл обработки всех событий из очереди
        // window.pollEvent() - извлекает событие из очереди (SFML 3 API)
        while (auto event = window.pollEvent())
        {
            // Проверяем, является ли событие закрытием окна
            if (event->is<sf::Event::Closed>())
            {
                // Закрываем окно, если пользователь нажал на крестик
                window.close();
            }
        }
        
        // === ЭТАП 2: ОБНОВЛЕНИЕ СОСТОЯНИЯ (АНИМАЦИЯ) ===
        // Увеличиваем время для создания анимации пульсации
        // deltaTime - время, прошедшее с последнего кадра
        // time накапливает общее время с начала программы
        time += deltaTime;
        
        // Вычисляем текущий радиус круга с помощью синусоиды
        // Формула: радиус = базовый_радиус + амплитуда * sin(скорость * время)
        // std::sin() - функция синуса из библиотеки <cmath>
        // sin() возвращает значение от -1 до 1
        // Умножаем на amplitude, чтобы получить изменение радиуса от -amplitude до +amplitude
        // Добавляем baseRadius, чтобы получить радиус от (baseRadius - amplitude) до (baseRadius + amplitude)
        float currentRadius = baseRadius + amplitude * std::sin(pulseSpeed * time * 2.0f * static_cast<float>(M_PI));
        
        // Устанавливаем новый радиус круга
        // setRadius() - устанавливает радиус круга
        // currentRadius - вычисленный радиус
        circle.setRadius(currentRadius);
        
        // Обновляем позицию круга, чтобы он оставался в центре
        // Когда радиус изменяется, нужно пересчитать позицию
        // 400 - центр окна по X, 300 - центр окна по Y
        // Вычитаем currentRadius для центрирования (позиция задается для левого верхнего угла)
        circle.setPosition({400 - currentRadius, 300 - currentRadius});
        
        // === ЭТАП 3: ОТРИСОВКА ===
        // Очищаем окно белым цветом перед отрисовкой нового кадра
        // window.clear() - заполняет все окно указанным цветом
        window.clear(sf::Color::White);
        
        // Рисуем круг на окне
        // window.draw() - добавляет фигуру в буфер отрисовки
        window.draw(circle);
        
        // Отображаем все нарисованное на экране
        // window.display() - выводит содержимое буфера на экран
        window.display();
    }
    
    // Возвращаем 0 - код успешного завершения программы
    return 0;
}

