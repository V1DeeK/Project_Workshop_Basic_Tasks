// Подключаем библиотеку SFML для работы с графикой
#include <SFML/Graphics.hpp>
// Подключаем библиотеку для работы со временем
#include <SFML/System.hpp>

// Главная функция программы
int main()
{
    // === СОЗДАНИЕ ОКНА ===
    // Создаем окно для отображения графики
    // sf::RenderWindow - класс для создания и управления окном
    // sf::VideoMode({800, 600}) - размер окна: ширина 800, высота 600
    // "Bouncing Ball" - заголовок окна
    sf::RenderWindow window(sf::VideoMode({800, 600}), "Bouncing Ball");
    
    // === СОЗДАНИЕ ШАРИКА ===
    // Создаем круг для шарика
    // sf::CircleShape(30) - создает круг с радиусом 30 пикселей
    sf::CircleShape ball(30);
    // Устанавливаем цвет заливки шарика - красный
    ball.setFillColor(sf::Color::Red);
    
    // === ПЕРЕМЕННЫЕ ДЛЯ ФИЗИКИ ===
    // Позиция шарика
    // sf::Vector2f - вектор из двух float значений (x, y)
    // 400, 300 - начальная позиция в центре окна
    sf::Vector2f position(400.0f, 300.0f);
    
    // Скорость шарика (пикселей в секунду)
    // velocity - вектор скорости (направление и величина)
    // 200, 150 - начальная скорость по осям X и Y
    sf::Vector2f velocity(200.0f, 150.0f);
    
    // === ОСНОВНОЙ ЦИКЛ ПРОГРАММЫ (GAME LOOP) ===
    // Создаем часы для измерения времени между кадрами
    // sf::Clock - класс для измерения времени
    // clock - переменная для хранения времени
    sf::Clock clock;
    
    // Цикл работает, пока окно открыто
    while (window.isOpen())
    {
        // === ИЗМЕРЕНИЕ ВРЕМЕНИ ===
        // Получаем время, прошедшее с последнего кадра
        // clock.restart() - перезапускает часы и возвращает прошедшее время
        // asSeconds() - преобразует время в секунды (float)
        // deltaTime - время между кадрами в секундах
        float deltaTime = clock.restart().asSeconds();
        
        // === ЭТАП 1: ОБРАБОТКА СОБЫТИЙ ===
        // Цикл обработки всех событий из очереди
        // window.pollEvent() - извлекает событие из очереди (SFML 3 API)
        while (auto event = window.pollEvent())
        {
            // Проверяем, является ли событие закрытием окна
            if (event->is<sf::Event::Closed>())
            {
                // Закрываем окно, если пользователь нажал на крестик
                window.close();
            }
        }
        
        // === ЭТАП 2: ОБНОВЛЕНИЕ СОСТОЯНИЯ (ФИЗИКА) ===
        // Обновляем позицию шарика на основе скорости и времени
        // Формула: новая_позиция = старая_позиция + скорость * время
        // Это позволяет шарику двигаться с постоянной скоростью независимо от FPS
        position.x += velocity.x * deltaTime;  // Обновляем X координату
        position.y += velocity.y * deltaTime;   // Обновляем Y координату
        
        // Проверяем столкновение с правой границей окна
        // 800 - ширина окна, 30 - радиус шарика
        // Если шарик вышел за правую границу
        if (position.x + 30 > 800)
        {
            // Отскакиваем от правой границы
            position.x = 800 - 30;  // Устанавливаем позицию на границе
            velocity.x = -velocity.x;  // Меняем направление скорости по X (отскок)
        }
        
        // Проверяем столкновение с левой границей окна
        // Если шарик вышел за левую границу
        if (position.x - 30 < 0)
        {
            // Отскакиваем от левой границы
            position.x = 30;  // Устанавливаем позицию на границе
            velocity.x = -velocity.x;  // Меняем направление скорости по X (отскок)
        }
        
        // Проверяем столкновение с нижней границей окна
        // 600 - высота окна, 30 - радиус шарика
        // Если шарик вышел за нижнюю границу
        if (position.y + 30 > 600)
        {
            // Отскакиваем от нижней границы
            position.y = 600 - 30;  // Устанавливаем позицию на границе
            velocity.y = -velocity.y;  // Меняем направление скорости по Y (отскок)
        }
        
        // Проверяем столкновение с верхней границей окна
        // Если шарик вышел за верхнюю границу
        if (position.y - 30 < 0)
        {
            // Отскакиваем от верхней границы
            position.y = 30;  // Устанавливаем позицию на границе
            velocity.y = -velocity.y;  // Меняем направление скорости по Y (отскок)
        }
        
        // Устанавливаем новую позицию шарика
        // setPosition() - обновляет координаты фигуры
        // В SFML позиция круга задается для его левого верхнего угла описанного прямоугольника
        // Поэтому вычитаем радиус для центрирования
        ball.setPosition({position.x - 30, position.y - 30});
        
        // === ЭТАП 3: ОТРИСОВКА ===
        // Очищаем окно белым цветом перед отрисовкой нового кадра
        // window.clear() - заполняет все окно указанным цветом
        window.clear(sf::Color::White);
        
        // Рисуем шарик на окне
        // window.draw() - добавляет фигуру в буфер отрисовки
        window.draw(ball);
        
        // Отображаем все нарисованное на экране
        // window.display() - выводит содержимое буфера на экран
        window.display();
    }
    
    // Возвращаем 0 - код успешного завершения программы
    return 0;
}

